'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_PROPS = exports.BUFFER_SIZE = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _elementResizeEvent = require('element-resize-event');

var _elementResizeEvent2 = _interopRequireDefault(_elementResizeEvent);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactAddonsPureRenderMixin = require('react-addons-pure-render-mixin');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BUFFER_SIZE = exports.BUFFER_SIZE = 2;
var DEFAULT_PROPS = exports.DEFAULT_PROPS = {
  containerType: 'tbody',
  initialNumberOfItems: 15
};

var InfiniteScroll = function (_React$Component) {
  _inherits(InfiniteScroll, _React$Component);

  function InfiniteScroll() {
    var _this2 = this;

    _classCallCheck(this, InfiniteScroll);

    var _this = _possibleConstructorReturn(this, (InfiniteScroll.__proto__ || Object.getPrototypeOf(InfiniteScroll)).call(this));

    _this.extractItemsInfo = function () {
      if (!_this.state.itemHeight) {
        _this.updateHeights();
      }

      if (!_this.state.spacerType) {
        _this.setSpacerType();
      }
    };

    _this.updateHeights = function () {
      var itemHeight = _this.firstItem ? _this.firstItem.clientHeight : undefined;
      var visibleHeight = _this.container.clientHeight;
      var numberOfVisibleItems = Math.ceil(visibleHeight / itemHeight);

      _this.setState({
        itemHeight: itemHeight,
        fullHeight: _this.props.totalNumberOfItems * itemHeight,
        numberOfVisibleItems: numberOfVisibleItems
      });
    };

    _this.componentDidUpdate = function () {
      var lastRenderedIndex = _this.getLastRenderedIndex();
      var currentVeryLastIndex = _this.props.totalNumberOfItems - 1;
      var distanceToBottom = currentVeryLastIndex - lastRenderedIndex;

      var threshold = _this.state.numberOfVisibleItems + BUFFER_SIZE;
      if (distanceToBottom < threshold) {
        _this.fetchMoreItems();
      }
      _this.extractItemsInfo();
    };

    _this.fetchMoreItems = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (_this.props.hasMore) {
                _context.next = 2;
                break;
              }

              return _context.abrupt('return');

            case 2:
              if (!_this.state.isFetching) {
                _context.next = 4;
                break;
              }

              return _context.abrupt('return');

            case 4:

              _this.setState({ isFetching: true });
              _context.next = 7;
              return _this.props.fetchMore(_this.state.numberOfVisibleItems);

            case 7:
              if (_this.isStillMounted) {
                _this.setState({ isFetching: false });
              }

            case 8:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this2);
    }));

    _this.handleScroll = function () {
      if (_this.scrollAnimationRequest) return;

      if (window.requestAnimationFrame) {
        _this.scrollAnimationRequest = window.requestAnimationFrame(function () {
          _this.updateScrollPosition();
          _this.scrollAnimationRequest = null;
        });
      } else {
        _this.updateScrollPosition();
      }
    };

    _this.updateScrollPosition = function () {
      _this.setState({
        scrollTop: _this.container.scrollTop
      });
    };

    _this.state = {
      itemHeight: undefined,
      fullHeight: undefined,
      isFetching: false,
      numberOfVisibleItems: undefined,
      scrollTop: 0,
      spacerType: undefined
    };

    _this.shouldComponentUpdate = _reactAddonsPureRenderMixin.shouldComponentUpdate.bind(_this);
    return _this;
  }

  _createClass(InfiniteScroll, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.isStillMounted = true;
      (0, _elementResizeEvent2.default)(this.container, this.updateHeights);
      this.extractItemsInfo();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.isStillMounted = false;
    }
  }, {
    key: 'setSpacerType',
    value: function setSpacerType() {
      if (this.firstItem) {
        var spacerType = this.firstItem.tagName;
        this.setState({ spacerType: spacerType });
      }
    }
  }, {
    key: 'getFirstRenderedIndex',
    value: function getFirstRenderedIndex() {
      var firstVisibleIndex = this.getFirstVisibleIndex();
      return Math.max(0, firstVisibleIndex - BUFFER_SIZE);
    }
  }, {
    key: 'getLastRenderedIndex',
    value: function getLastRenderedIndex() {
      var numberOfVisibleItems = this.state.numberOfVisibleItems;


      if (!this.areHeightsReady()) return this.props.initialNumberOfItems;

      var firstVisibleIndex = this.getFirstVisibleIndex();
      var lastVisibleIndex = firstVisibleIndex + numberOfVisibleItems - 1;
      var lastBufferIndex = lastVisibleIndex + BUFFER_SIZE;

      var veryLastIndex = this.props.totalNumberOfItems - 1;
      return Math.min(veryLastIndex, lastBufferIndex);
    }
  }, {
    key: 'getFirstVisibleIndex',
    value: function getFirstVisibleIndex() {
      var _state = this.state;
      var scrollTop = _state.scrollTop;
      var itemHeight = _state.itemHeight;


      if (!this.areHeightsReady()) return 0;

      return Math.floor(scrollTop / itemHeight);
    }
  }, {
    key: 'areHeightsReady',
    value: function areHeightsReady() {
      return !!this.state.itemHeight;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      // Variable name has to have a capital letter as first letter to be well interpreted by JSX
      var ContainerType = this.props.containerType;
      var containerProps = {
        ref: function ref(c) {
          _this3.container = _reactDom2.default.findDOMNode(c);
        },
        style: this.props.containerStyle,
        onScroll: this.handleScroll
      };

      if (!this.props.totalNumberOfItems) {
        return _react2.default.createElement(ContainerType, containerProps);
      }

      var items = this.renderItems();
      var firstItem = _react2.default.cloneElement(items[0], { ref: function ref(c) {
          _this3.firstItem = _reactDom2.default.findDOMNode(c);
        } });
      var restOfItems = items.slice(1);

      return _react2.default.createElement(
        ContainerType,
        containerProps,
        this.renderAboveSpacer(),
        firstItem,
        restOfItems,
        this.renderBottomSpacer(),
        this.renderLoader()
      );
    }
  }, {
    key: 'renderItems',
    value: function renderItems() {
      var fromIndex = this.getFirstRenderedIndex();
      var toIndex = this.getLastRenderedIndex();

      return this.props.renderItems(fromIndex, toIndex);
    }
  }, {
    key: 'renderAboveSpacer',
    value: function renderAboveSpacer() {
      var SpacerType = this.state.spacerType;
      if (!SpacerType) return;

      var height = 0;

      if (this.areHeightsReady()) {
        var numberOfItemsToReplace = this.getFirstRenderedIndex();
        height = numberOfItemsToReplace * this.state.itemHeight;
      }

      return _react2.default.createElement(SpacerType, { style: { height: height } });
    }
  }, {
    key: 'renderBottomSpacer',
    value: function renderBottomSpacer() {
      var SpacerType = this.state.spacerType;
      if (!SpacerType) return;

      var height = 0;

      if (this.areHeightsReady()) {
        var totalNumberOfItems = this.props.totalNumberOfItems;
        var numberOfItemsBefore = this.getLastRenderedIndex() + 1;
        var numberOfItemsToReplace = totalNumberOfItems - numberOfItemsBefore;
        height = numberOfItemsToReplace * this.state.itemHeight;
      }

      return _react2.default.createElement(SpacerType, { style: { height: height } });
    }
  }, {
    key: 'renderLoader',
    value: function renderLoader() {
      if (this.state.isFetching) {
        return this.props.loader;
      }
    }
  }]);

  return InfiniteScroll;
}(_react2.default.Component);

InfiniteScroll.propTypes = {
  containerStyle: _react.PropTypes.object,
  containerType: _react.PropTypes.string,
  hasMore: _react.PropTypes.bool.isRequired,
  initialNumberOfItems: _react.PropTypes.number,
  loader: _react.PropTypes.node.isRequired,
  totalNumberOfItems: _react.PropTypes.number.isRequired,

  fetchMore: _react.PropTypes.func.isRequired,
  renderItems: _react.PropTypes.func.isRequired
};
InfiniteScroll.defaultProps = DEFAULT_PROPS;
exports.default = InfiniteScroll;